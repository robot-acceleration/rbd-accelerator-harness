/*****************************************************************
 * Experiment Helpers
 * 
 * Need to build doc
 *
 *****************************************************************/
#include <lcm/lcm-cpp.hpp>
#include "../lcmtypes/drake/lcmt_iiwa_status.hpp"
#include "../lcmtypes/drake/lcmt_iiwa_command_hardware.hpp"
#include "../lcmtypes/drake/lcmt_trajectory_f.hpp"
#include "../lcmtypes/drake/lcmt_trajectory_d.hpp"
#include "../lcmtypes/drake/lcmt_target_twist.hpp"
#include "../lcmtypes/drake/lcmt_cost_params.hpp"
#include <type_traits>

const char *ARM_GOAL_CHANNEL    = "GOAL_CHANNEL";
const char *ARM_TRAJ_CHANNEL    = "TRAJ_CHANNEL";
const char *ARM_COMMAND_CHANNEL = "IIWA_COMMAND";
const char *ARM_STATUS_CHANNEL  = "IIWA_STATUS";
const char *COST_PARAMS_CHANNEL = "COST_PARAMS_CHANNEL";
const char *ARM_STATUS = "IIWA_STATUS";

#include <random>
#define RANDOM_MEAN 0.0
#define RANDOM_STDEV 0.001
#define PI 3.14159

std::default_random_engine randEng(time(0)); //seed
std::normal_distribution<double> randDist(RANDOM_MEAN, RANDOM_STDEV); //mean followed by stdiv

template <typename T>
T getRand(){return static_cast<T>(randDist(randEng));}

bool tryParse(std::string& input, int& output) {
	try{output = std::stoi(input);}
	catch (std::invalid_argument) {return false;}
	return true;
}

template <char exitC>
int getInt(int maxInt, int minInt){
   std::string input;	std::string exitCode (1,exitC); int x;
   while(1){
      getline(std::cin, input);
      while (!tryParse(input, x)){
         if (input.compare(input.size()-1,1,exitCode) == 0){return -1;}
         std::cout << "Bad entry. Enter a NUMBER\n";	getline(std::cin, input);
      }
      if (x >= minInt && x <= maxInt){break;}
      else{std::cout << "Entry must be in range[" << minInt << "," << maxInt << "]\n";}
   }
   return x;
}

void keyboardHold(){std::string input;	getline(std::cin, input);}

template <typename T, int NUM_LINKS, bool USING_MPC_MODE>
void loadPoint(T *xk, T *uk = nullptr){
	if(!USING_MPC_MODE){
		xk[0] = -0.5*PI;		xk[1] = 0.25*PI;	xk[2] = 0.167*PI;
		xk[3] = -0.167*PI;		xk[4] = 0.125*PI;	xk[5] = 0.167*PI;	xk[6] = 0.5*PI;
		for (int k2=0; k2<NUM_LINKS; k2++){xk[NUM_POS+k2] = getRand<T>() + 0.01;}//xk[k2] += 0.01; }
		if (uk != nullptr){
			uk[0] = 0.005055; 		uk[1] = -62.278098; 	uk[2] = 4.177923;
			uk[3] = 21.518790; 		uk[4] = -0.083672; 		uk[5] = -0.885623; 	uk[6] = 0.0050;
			// for (int k2=0; k2<NUM_LINKS; k2++){uk[k2] += getRand<T>() + 0.01;}
		}
	}
	else{
		for (int k2=0; k2<STATE_SIZE; k2++){xk[k2] = 0.0;}
		xk[1] = PI/4.0; xk[3] = -PI/4.0; xk[5] = PI/4.0;
		if (uk != nullptr){
			for (int k2=0; k2<CONTROL_SIZE; k2++){uk[k2] = 0.0;}
		}
	}
}

template <typename T, int KNOT_POINTS, int NUM_LINKS, bool USING_MPC_MODE>
void loadXU(T *x, T *u, int ld_x, int ld_u, T *KT = nullptr, int ld_KT = 0){
	for (int k=0; k<KNOT_POINTS; k++){loadPoint<T,NUM_LINKS,USING_MPC_MODE>(&x[k*ld_x],&u[k*ld_u]);}
	if(KT != nullptr){memset(KT, 0, ld_KT*DIM_KT_c*KNOT_POINTS*sizeof(T));}
}

template <typename T, bool EE_COST_MODE>
void loadSingleGoal(T *xGoal){
	if(EE_COST_MODE){
		// EE Single Goal
		T GOAL_X = 0.3638;
		T GOAL_Y = 0.0;
		T GOAL_Z = 1.0628;
		T GOAL_r = (0.5*PI);
		T GOAL_p = 0.0;
		T GOAL_y = (0.5*PI);
		const T temp[] = {GOAL_X,GOAL_Y,GOAL_Z,GOAL_r,GOAL_p,GOAL_y};
		for (int i=0; i < 6; i++){xGoal[i] = temp[i];}
	}
	else{
		// Joint Single  Goal
		T GOAL_1 = 0.0;
		T GOAL_2 = 0.0;
		T GOAL_3 = 0.0;
		T GOAL_4 = -0.25*PI;
		T GOAL_5 = 0.0;
		T GOAL_6 = 0.25*PI;
		T GOAL_7 = 0.5*PI;
		T GOAL_O = 0.0;
		const T temp[] = {GOAL_1,GOAL_2,GOAL_3,GOAL_4,GOAL_5,GOAL_6,GOAL_7,GOAL_O,GOAL_O,GOAL_O,GOAL_O,GOAL_O,GOAL_O,GOAL_O};
		for (int i=0; i < STATE_SIZE; i++){xGoal[i] = temp[i];}
	}
}

void computeStats(double *_median, double *_avg, double *_stdev, double *_min, double *_max, std::vector<double> v){
	// sort gives us the median, max and min
	int size = v.size();
    std::sort(v.begin(),v.end());
	*_median = size % 2 ? v[size / 2] : (v[size / 2 - 1] + v[size / 2]) / 2.0;	
	*_max = v.back();	
	*_min = v.front();
	// sum gives use the average
	double sum = std::accumulate(v.begin(), v.end(), 0.0);		
	*_avg = sum / (double)size;	
	// and then the std dev	
	*_stdev = 0.0;
	for(std::vector<double>::iterator it = v.begin(); it != v.end(); ++it){
		*_stdev += pow(*it-*_avg,2.0);
	}
	*_stdev /= (double) size;	
	*_stdev = pow(*_stdev,0.5);
}

void printStats(std::vector<double> v, const char *type){
	double _median, _avg, _stdev, _min, _max;
	computeStats(&_median, &_avg, &_stdev, &_min, &_max, v);
	printf("%s: Median[%f] Average[%f] StdDev[%f] max[%f] min[%f]\n",type,_median,_avg,_stdev,_max,_min);
}

void printStats(const char *strMain, std::vector<double> test_times, const char *str1 = nullptr, std::vector<double> test_times1 = std::vector<double>(), const char *str2 = nullptr, std::vector<double> test_times2 = std::vector<double>(), 
				const char *str3 = nullptr, std::vector<double> test_times3 = std::vector<double>(), const char *str4 = nullptr, std::vector<double> test_times4 = std::vector<double>(), const char *str5 = nullptr, std::vector<double> test_times5 = std::vector<double>()){
	printf("-----------------\n");
	printStats(test_times,strMain);
	test_times.clear();
	if(test_times1.size() && str1 != nullptr){printStats(test_times1,str1); test_times1.clear();}
	if(test_times2.size() && str2 != nullptr){printStats(test_times2,str2); test_times2.clear();}
	if(test_times3.size() && str3 != nullptr){printStats(test_times3,str3); test_times3.clear();}
	if(test_times4.size() && str4 != nullptr){printStats(test_times4,str4); test_times4.clear();}
	if(test_times5.size() && str5 != nullptr){printStats(test_times5,str5); test_times5.clear();}
	printf("-----------------\n");
}

template<int TIMING_ITERS, int MAX_ITERS>
void printTimingStats(double *arr, int iters, char *type, int vals_per_test = MAX_ITERS){
	// get all the vals into a vector
    std::vector<double> v; for (int test=0; test<TIMING_ITERS; test++){for (int i=0; i<iters; i++){v.push_back(arr[test*vals_per_test + i]);}}
	// report results
	printStats(v,type);
}

template<int TIMING_ITERS, int MAX_ITERS>
void printPerIterTiming(double *initTime, double *fsimTime, double *fsweepTime, double *bpTime, double *nisTime){
	// the total time to each cost point is:
	//   t[i+1] = fsim[i] + fsweep[i] + bp[i] + nis[i-1] + t[i]
	//   t[1] = init + fsim[0] + fsweep[0] + bp[0]
	//   t[0] = 0
	double _median, _avg, _stdev, _min, _max;
	double TIMES[MAX_ITERS+1];	TIMES[0] = 0.0;
	for (int iter = 0; iter < MAX_ITERS; iter++){
		// collect the vector for this time step
		std::vector<double> v;
		for (int test=0; test<TIMING_ITERS; test++){
			int ind = test*MAX_ITERS + iter;
			double val = fsimTime[ind] + fsweepTime[ind] + bpTime[ind] + (iter > 0 ? nisTime[ind-1]	: initTime[test]);
			v.push_back(val);
		}
		// compute the stats
		computeStats(&_median, &_avg, &_stdev, &_min, &_max, v);
		// printf("Full Timing Per Iter[%d]: Median[%f] Average[%f] StdDev[%f] max[%f] min[%f]\n",iter+1,_median,_avg,_stdev,_max,_min);
		TIMES[iter+1] = _median + TIMES[iter];
	}
	printf("Median Time Trace:\n");
	for (int iter = 0; iter <= MAX_ITERS; iter++){printf("%f ",TIMES[iter]);} printf("\n");
}

template<int TIMING_ITERS, int MAX_ITERS>
void printAllTimingStats(double *tTime, double *initTime, double *fsimTime, double *fsweepTime, double *bpTime, double *nisTime, \
						 double *nisTime1 = nullptr, double *nisTime2 = nullptr, double *nisTime3 = nullptr, double *nisTime4 = nullptr, double *nisTime5 = nullptr, double *nisTime6 = nullptr){
	char tot[]  = " TOT";	char init[] = "INIT";	char fp[]   = "  FP";	char fs[]   = "  FS";	char bp[]   = "  BP";	char nis[]  = " NIS";
	printPerIterTiming<TIMING_ITERS,MAX_ITERS>(initTime,fsimTime,fsweepTime,bpTime,nisTime);
	while(1){   
		// ask for which iter to stop timing stats on
		printf("Which iter would you like to stop timing on (q to exit)?\n");
		int timingIters = getInt<'q'>(MAX_ITERS,1);
		if (timingIters == -1){break;}
		// print those stats
		printTimingStats<TIMING_ITERS,MAX_ITERS>(tTime,TIMING_ITERS,tot,1);
		printTimingStats<TIMING_ITERS,MAX_ITERS>(initTime,TIMING_ITERS,init,1);
		printTimingStats<TIMING_ITERS,MAX_ITERS>(fsimTime,timingIters,fp);
		printTimingStats<TIMING_ITERS,MAX_ITERS>(fsweepTime,timingIters,fs);
		printTimingStats<TIMING_ITERS,MAX_ITERS>(bpTime,timingIters,bp);
		printTimingStats<TIMING_ITERS,MAX_ITERS>(nisTime,timingIters,nis);
		if(nisTime1 != nullptr){
			printTimingStats<TIMING_ITERS,MAX_ITERS>(nisTime1,timingIters,nis);
			printTimingStats<TIMING_ITERS,MAX_ITERS>(nisTime2,timingIters,nis);
			printTimingStats<TIMING_ITERS,MAX_ITERS>(nisTime3,timingIters,nis);
			printTimingStats<TIMING_ITERS,MAX_ITERS>(nisTime4,timingIters,nis);
			printTimingStats<TIMING_ITERS,MAX_ITERS>(nisTime5,timingIters,nis);
			printTimingStats<TIMING_ITERS,MAX_ITERS>(nisTime6,timingIters,nis);
		}
   }
}

template <typename T, int TIMING_ITERS, int MAX_ITERS>
void printJAlphaStats(T *Jout, int *alphaOut){
	double _median, _avg, _stdev, _min, _max, _median2, _avg2, _stdev2, _min2, _max2;
	std::vector<double> MEDIANS;
	// for(int i = 0; i < TIMING_ITERS; i++){
	// 	printMat<int,1,MAX_ITERS+1>(&alphaOut[(MAX_ITERS+1)*i],1);
	// }
	for (int iter = 0; iter <= MAX_ITERS; iter++){
		std::vector<double> v;	std::vector<double> v2;
		for (int i=0; i<TIMING_ITERS; i++){v.push_back((double)Jout[i*(MAX_ITERS+1) + iter]);	v2.push_back((double)alphaOut[i*(MAX_ITERS+1) + iter]);}
		computeStats(&_median, &_avg, &_stdev, &_min, &_max, v);
		computeStats(&_median2, &_avg2, &_stdev2, &_min2, &_max2, v2);
		MEDIANS.push_back(_median);
		printf("Iter %d: Median[%f] Average[%f] StdDev[%f] max[%f] min[%f] alpha[%.1f,%.1f,%.1f,%.0f,%.0f]\n",iter,_median,_avg,_stdev,_max,_min,_median2,_avg2,_stdev2,_max2,_min2);
	}
	printf("Median J Trace:\n");
	for(std::vector<double>::iterator it = MEDIANS.begin(); it != MEDIANS.end(); ++it){printf("%f ",*it);}printf("\n");
}

template <typename T>
void printAllTimingStats(algTrace<T> *atrace){
	char tot[]  = "  TOT"; char init[] = " INIT";	char fsim[] = "  SIM"; char fsweep[] = "SWEEP"; char bp[] = "   BP"; char nis[] = "  NIS";
	printStats(atrace->tTime,tot);
	printStats(atrace->initTime,init);
	printStats(atrace->simTime,fsim);
	printStats(atrace->sweepTime,fsweep);
	printStats(atrace->bpTime,bp);
	printStats(atrace->nisTime,nis);
}

template <typename T>
void evNorm(T *xActual, T *xGoal, T *eNorm, T *vNorm, T *eePos){
	T s_deePos[6*NUM_POS]; T s_tempMem[34*NUM_POS]; T s_dtempMem[49*NUM_POS];
	computedEEPos4x4_scratch<T>(eePos,xActual,s_tempMem,s_deePos,s_dtempMem);
	*eNorm = 0; for(int i=0;i<3;i++){T delta = eePos[i]-xGoal[i]; *eNorm+=delta*delta;} *eNorm = static_cast<T>(sqrt(*eNorm));
	*vNorm = 0; for(int i=0;i<NUM_POS;i++){*vNorm+=xActual[NUM_POS+i]*xActual[NUM_POS+i];} *vNorm = static_cast<T>(sqrt(*vNorm));
}

template <typename T>
void evNorm(T *xActual, T *xGoal, T *eNorm, T *vNorm){T eePos[NUM_POS];   evNorm(xActual,xGoal,eNorm,vNorm,eePos);}

template <typename T>
int loadFig8Goal(T *goal, double time, double totalTime, T *xGoals, T *yGoals, T *zGoals){
	int numGoals = 200; 	double tstep = totalTime/(numGoals-1);	double goalNum = time/tstep;
	T fraction = static_cast<T>(goalNum - std::floor(goalNum));		int rep = static_cast<int>(std::floor(goalNum)) / numGoals;
	int rd = static_cast<int>(std::floor(goalNum)) % numGoals;		int ru = static_cast<int>(std::ceil(goalNum)) % numGoals;
	goal[0] = ((T)1-fraction)*xGoals[rd] + fraction*xGoals[ru];		goal[3] = 0.0;
	goal[1] = ((T)1-fraction)*yGoals[rd] + fraction*yGoals[ru];		goal[4] = 0.0;
	goal[2] = ((T)1-fraction)*zGoals[rd] + fraction*zGoals[ru];		goal[5] = 0.0;
	return rep;
}

template <typename T>
int loadFig8Goal(T *goal, double time, double totalTime = 1){
	T xGoals[] = {0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004};
	T yGoals[] = {0.13686922001827645,0.1281183229143938,0.11926059413541247,0.11030432312999372,0.1012577993467988,0.09212931223448896,0.08292715124172548,0.0736596058171696,0.06433496540948258,0.05496151946732569,0.045547557439360176,0.03610136877424733,0.026631242920648335,0.017145469327224508,0.007652337442637103,-0.001839863284452653,-0.011322843405383448,-0.020788313471494096,-0.030227984034123273,-0.039633565644609764,-0.0489967688542923,-0.05830930421450961,-0.06756288227660043,-0.07674921359190354,-0.08586000871175764,-0.09488697818749958,-0.1038655258329727,-0.11272375591745916,-0.12145267616480321,-0.13004109492853494,-0.13848752180117063,-0.1467858524541864,-0.1549281455978588,-0.1629165235905652,-0.1707482796892309,-0.17841599130217783,-0.18591882035832843,-0.1932502389635062,-0.20040076105913676,-0.20735798772338723,-0.21411519853223893,-0.22066551450768562,-0.2269966386554578,-0.2331053523296066,-0.23897989082424964,-0.24461177603116246,-0.24999586174091798,-0.255127737887603,-0.2600037985005273,-0.264623973362925,-0.2689800086072113,-0.27306787696210033,-0.2768840041676995,-0.2804279779836409,-0.28369462501981374,-0.28667669709392635,-0.2893761036490012,-0.29178950599107006,-0.29391158123626243,-0.29574034972478985,-0.29727453396452347,-0.29851358128156347,-0.2994544451742904,-0.30009482660988346,-0.30043907902783173,-0.30048644363405164,-0.3002369544043975,-0.29968819678814346,-0.2988444313574429,-0.2977048064508765,-0.2962719042333858,-0.29454317198576974,-0.2925200231035754,-0.2902045731500091,-0.2876022809123594,-0.2847133796914938,-0.28154140071122247,-0.27809048676073667,-0.27436270583704647,-0.2703665745543449,-0.26610524813698555,-0.26158238012185503,-0.25680474076422527,-0.2517742032662073,-0.2464935808285531,-0.24096598110942027,-0.23519855715870805,-0.22919065210989617,-0.22294815964121067,-0.216477551020404,-0.20978904844956445,-0.20289009717093992,-0.19578529751522875,-0.18849136560284127,-0.1810102720333381,-0.17335332623615154,-0.16552932116242403,-0.15754446533330008,-0.1494055335341655,-0.141119776212369,-0.13269158757842503,-0.12412621123921029,-0.11543344583116043,-0.10661783052843572,-0.09768974155699829,-0.08866263788534111,-0.07955032956578706,-0.07036309089673469,-0.06111613853088287,-0.051824258760106816,-0.04250384833178472,-0.03316965050170948,-0.02383739609051122,-0.014517898480146497,-0.00521285872839692,0.004084069854356758,0.013377716369566438,0.022678964415954628,0.03199791841264746,0.04134623887290685,0.05072829056150665,0.06014998301207159,0.06960936374549687,0.07908892160637689,0.08855068744478754,0.09794356384062872,0.10720878615596977,0.11629326145552335,0.12514991959047528,0.13374545516319478,0.14207020091055017,0.15012393938707272,0.15792746608076888,0.16551126865840357,0.1729042968130615,0.18013571994835326,0.1872239892183252,0.19418299168723718,0.20100573965434845,0.2076839316858779,0.2142059797503866,0.22054968628960595,0.22669845070103078,0.2326348093954518,0.2383522458039774,0.24384287073319427,0.2491022174907651,0.2541293098371375,0.2589202699947854,0.2634683865999179,0.2677700650071298,0.27181899023759926,0.2756002672767167,0.2791048721375289,0.28231577838682104,0.28522354073704403,0.2878230537497963,0.2901076694828819,0.2920783437903407,0.29374310403406084,0.295107993386028,0.2961895263765827,0.2970056784978085,0.2975819271104611,0.29794495005548816,0.298109264082986,0.2980740741579594,0.2978323971097816,0.2973591836734637,0.296622924641549,0.2955794967043364,0.29418154658089085,0.2923728011959445,0.2900962060295761,0.2873037962354698,0.28396753800504204,0.28032650994085717,0.2763886650341475,0.27216195627614015,0.26765433665806226,0.2628737591711411,0.2578281768066035,0.25252554255567694,0.2469738094095883,0.2411809303595648,0.2351548583968336,0.2289035465126218,0.22243494769815644,0.21575701494466482,0.208877701243374,0.201804959585511,0.19454674296230312,0.1871110043649775,0.179505696784761,0.1717387732128811,0.16381818664056474,0.1557518900590391,0.14754783645953137,0.1392139788332685,0.1307582701714778};
	T zGoals[] = {0.31756840547539744,0.32748579299353975,0.3378005717933035,0.3484792783644661,0.3594884491968049,0.3707946207800972,0.38236432960412026,0.39416411215865155,0.40616050493346834,0.4183200444183479,0.4306092671030677,0.44299470947740494,0.455442908031137,0.4679203992540413,0.48039371963589506,0.49282940566647565,0.5051939938355604,0.5174540206329267,0.5295760225483518,0.541526536071613,0.5532720976924878,0.5647792439007534,0.5760145111861872,0.5869444360385665,0.5975355549476685,0.607754404403259,0.617684862624283,0.6269833110602612,0.6356398015809976,0.6436439919363848,0.6509877754875409,0.6576613603932012,0.6636610682008525,0.6689826360732843,0.67361769235995,0.6775587102765505,0.6807894425694675,0.6832982853518634,0.6850685995152646,0.6860878343790213,0.6863475050397387,0.6858378423067206,0.6845542073433015,0.6824970237151333,0.679674950734998,0.6760903644476528,0.6717601780334646,0.6666986364356934,0.6609289904640975,0.6544774785385726,0.6473731907857357,0.6396420054814256,0.6313175949625012,0.6224353167682047,0.6130293234274724,0.6031408593626014,0.592806201725962,0.5820708170060365,0.5709740379170426,0.5595578699404182,0.5478698928627949,0.5359537973679934,0.5238581689279385,0.5116302430406027,0.4993208702348768,0.48697884889804044,0.4746532265736393,0.4623956012593628,0.4502485492310045,0.4382596910462214,0.42647866542842733,0.41494764320821875,0.4037154159777041,0.39282851027202587,0.3823335341683771,0.37227688282859595,0.36269856168881953,0.3536372194160615,0.3451304536909037,0.33721132075471055,0.32990808625336293,0.32324779496703726,0.3172587080115004,0.31196097533352374,0.3073723368592661,0.3035111825862362,0.3003931753833552,0.29803437903462704,0.2964420439874006,0.29562574916758594,0.2955914743255737,0.29633569503272444,0.29786307504133164,0.3001661781693752,0.30323465990169074,0.3070520940451594,0.3115998595664622,0.31685456748736623,0.3227967201975068,0.32939373258736826,0.336620401368088,0.34444137126548074,0.35282689981652365,0.3617486647489115,0.37117885795827055,0.3810878162585716,0.39144908831456365,0.4022280096944361,0.41338530657545247,0.42488278556704895,0.43667841400710394,0.4487240639652002,0.46096913859882693,0.47336419850958344,0.48584480962195276,0.4983474665337738,0.5108078008561817,0.5231640943169621,0.5353543092708679,0.5473260617454424,0.5590277695983947,0.5704169154454125,0.5814512174681081,0.5920942512854084,0.6023199392964617,0.6120999705542476,0.6214094905886763,0.6302189177557694,0.6384948605857313,0.6462095585403849,0.6533240617001391,0.6598152959296799,0.6656559786178493,0.6708180864798622,0.6752789417653723,0.6790134023420558,0.6819951301275096,0.6841972139799184,0.6856012933475145,0.6861863032005122,0.6859428344922742,0.6848659833744687,0.6829691340687087,0.6802671521438632,0.6767869940428872,0.6725559197263683,0.6675988289655357,0.6619506036376687,0.6556389703050904,0.6486908922059266,0.6411394935332501,0.6330153548211616,0.6243554553896911,0.6151955559582207,0.6055661079526033,0.5954998822170263,0.5850395750753018,0.5742180207932119,0.563083467349193,0.5516783030193103,0.5400466850891197,0.5282336225055959,0.5162846587691582,0.5042482411832561,0.49216898910506657,0.4800977462683095,0.4680759949262634,0.45614115835012375,0.4443280391401759,0.4326669709393109,0.42118572108087715,0.40991017010577024,0.3988536909103188,0.3880358943577357,0.37746325851094437,0.3677153816185399,0.3583626678734707,0.34943548878219216,0.34096421585115233,0.33297922058679913,0.3255108744955808,0.3185895490839454,0.31224561585834093,0.30650944632521565,0.30141141199101745,0.2969818843621946,0.29325123494519506,0.29024983524646697,0.28800805677245844,0.2865562710296175,0.28592484952439223,0.2861441637632308,0.28724458525258123,0.2892564854988917,0.2922102360086102,0.2961362082881848,0.30106477384406377,0.30702630418269494,0.3140511708105266,0.32216974523400665};
	return loadFig8Goal<T>(goal,time,totalTime,xGoals,yGoals,zGoals);
}

template <typename T>
void loadInitialFig8GoalNomActual(T *goal, T *nom, T *actual){loadFig8Goal<T>(goal,0); loadPoint<T,NUM_POS,1>(nom); loadPoint<T,NUM_POS,1>(actual);}

template <typename T, int KNOT_POINTS, int SUBSTEPS, bool MPC_MODE = false>
T simulateForward(T *x, T *u, T *KT, T *xActual, int ld_x, int ld_u, int ld_KT, double elapsedTime, double goalTime, double totalTime, double t0){
	double I[36*NUM_POS]; double Tbody[36*NUM_POS]; initI<double>(I); initT<double>(Tbody);
	// and break elapsed time into SUBSTEPS for accuracy
	double qdes[NUM_POS], udes[CONTROL_SIZE], currX[STATE_SIZE], nextX[STATE_SIZE], qdd[NUM_POS], Minv[NUM_POS*NUM_POS];
	double dt_us = elapsedTime/static_cast<double>(SUBSTEPS); double dt = dt_us / 1000000.0; double tk = t0;
	for(int j=0; j < STATE_SIZE; j++){currX[j] = static_cast<double>(xActual[j]);}
	T totalError = 0;	T goal[3];	T eNorm, vNorm; T currX_T[STATE_SIZE];
	for(int i = 0; i < SUBSTEPS; i++){
		// get the goal and compute the error norm
		for(int j=0; j < STATE_SIZE; j++){currX_T[j] = (T)currX[j];}
		loadFig8Goal<T>(&goal[0],goalTime,totalTime);	evNorm<T>(currX_T,goal,&eNorm,&vNorm);	totalError += eNorm;
		// then get controls
		int err = getHardwareControls<T,KNOT_POINTS,KNOT_POINTS>(&(qdes[0]), &(udes[0]), x, u, KT, t0, tk, &(currX[0]), &(currX[NUM_POS]), ld_x, ld_u, ld_KT);
		if(err){printf("CRITICAL FAILURE ERROR ABORT MISSION\n");return 0;}
		// apply them
		forwardDynamics<double,MPC_MODE>(qdd,udes,&currX[NUM_POS],currX,I,Tbody,Minv);
		for (int ind = 0; ind < NUM_POS; ind++){
			nextX[ind] 			= currX[ind] 			+ dt*currX[ind+NUM_POS];
			nextX[ind+NUM_POS] 	= currX[ind+NUM_POS] 	+ dt*qdd[ind];
		}
		for(int j=0; j < STATE_SIZE; j++){currX[j] = nextX[j];}		tk += dt_us;
	}
	#pragma unroll
	for(int j=0; j < STATE_SIZE; j++){xActual[j] = (T)currX[j]; currX_T[j] = xActual[j];}
	loadFig8Goal<T>(&goal[0],goalTime,totalTime);	evNorm<T>(currX_T,goal,&eNorm,&vNorm);	totalError += eNorm;
	return (totalError / static_cast<T>(SUBSTEPS));
}

template <typename T, int KNOT_POINTS, int SUBSTEPS = 150, bool MPC_MODE = false, int debugMode = 1>
int fig8Simulate(T *x, T *u, T *KT, T *xActual, T *xGoal, int ld_x, int ld_u, int ld_KT, T *error, double *goalTime, double *timePrint, int *counter, int *initial_convergence_flag,
	             double elapsedTime_us, double totalTime_us, T eNormLim, T vNormLim, bool doFig8){
	*error += simulateForward<T,KNOT_POINTS,SUBSTEPS,MPC_MODE>(x,u,KT,xActual,ld_x,ld_u,ld_KT,elapsedTime_us,(*goalTime),totalTime_us,0);
	// print where are we ending up and expected
	if(debugMode == 2){
		double timeStep_us = TOTAL_TIME_us/(KNOT_POINTS-1);
		int timeStepsTaken = static_cast<int>(elapsedTime_us/timeStep_us);
		printf("[%d] Sim of %.4f is %d steps goes to:\n",*counter,elapsedTime_us,timeStepsTaken);
		printMat<T,1,STATE_SIZE>(xActual,1);
		printf(" With expected:\n");
		printMat<T,1,STATE_SIZE>(x + timeStepsTaken*ld_x,1);
	}
	// print the state we sim to
	if (debugMode == 3){
		printf("%f,%f,%f,%f,%f,%f,%f,%f\n",*timePrint,xActual[0],xActual[1],xActual[2],xActual[3],xActual[4],xActual[5],xActual[6]);
		*timePrint += elapsedTime_us;
	}
	// compute eePos error if computing Fig 8 or debugMode 1
	if(doFig8 || debugMode == 1){
		T eePos[NUM_POS]; T s_deePos[6*NUM_POS]; T s_tempMem[34*NUM_POS]; T s_dtempMem[49*NUM_POS];
		computedEEPos4x4_scratch<T>(eePos,xActual,s_tempMem,s_deePos,s_dtempMem);
		T eNorm = 0; 		T vNorm = 0; 		evNorm<T>(xActual, xGoal, &eNorm, &vNorm);
		// debug print eePos if needed
		// if (debugMode == 1){printf("[t[%f],EE[%f,%f,%f],Goal[%f,%f,%f],E[%f],avgE[%f],V[%f]]\n",*goalTime,eePos[0],eePos[1],eePos[2],xGoal[0],xGoal[1],xGoal[2],eNorm,(*error)/(*counter),vNorm);}
		if (debugMode == 1){printf("[[%f,%f,%f],[%f,%f,%f],%f,%f,%f],\n",eePos[0],eePos[1],eePos[2],xGoal[0],xGoal[1],xGoal[2],eNorm,(*error)/(*counter),vNorm);}
		// update goals if doing figure 8
		if (doFig8){
			// if in figure 8 increment goalTime and see if we are ready to exit
			if(*initial_convergence_flag){*goalTime += elapsedTime_us;	if(loadFig8Goal<T>(xGoal,*goalTime,totalTime_us) > 0){return 1;}}
			// else see if we are ready to start the figure 8
			else if(eNorm < eNormLim && vNorm < vNormLim){*initial_convergence_flag = 1; *error = 0; *counter = 0;}
		}
	}
	return 0;
}

template <typename T>
class LCM_Fig8Goal_Handler {
    public:
    	double totalTime, zeroTime, eNormLim, vNormLim, totalError;	
    	int inFig8, costSent, numIters, currRep;
    	lcm::LCM lcm_ptr; // ptr to LCM object for publish ability
    	struct timeval start, end; int timeCount; double timeTotal;
    	// and the goals
		T xGoals[200] = {0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004,0.6556285000000004};
		T yGoals[200] = {0.13686922001827645,0.1281183229143938,0.11926059413541247,0.11030432312999372,0.1012577993467988,0.09212931223448896,0.08292715124172548,0.0736596058171696,0.06433496540948258,0.05496151946732569,0.045547557439360176,0.03610136877424733,0.026631242920648335,0.017145469327224508,0.007652337442637103,-0.001839863284452653,-0.011322843405383448,-0.020788313471494096,-0.030227984034123273,-0.039633565644609764,-0.0489967688542923,-0.05830930421450961,-0.06756288227660043,-0.07674921359190354,-0.08586000871175764,-0.09488697818749958,-0.1038655258329727,-0.11272375591745916,-0.12145267616480321,-0.13004109492853494,-0.13848752180117063,-0.1467858524541864,-0.1549281455978588,-0.1629165235905652,-0.1707482796892309,-0.17841599130217783,-0.18591882035832843,-0.1932502389635062,-0.20040076105913676,-0.20735798772338723,-0.21411519853223893,-0.22066551450768562,-0.2269966386554578,-0.2331053523296066,-0.23897989082424964,-0.24461177603116246,-0.24999586174091798,-0.255127737887603,-0.2600037985005273,-0.264623973362925,-0.2689800086072113,-0.27306787696210033,-0.2768840041676995,-0.2804279779836409,-0.28369462501981374,-0.28667669709392635,-0.2893761036490012,-0.29178950599107006,-0.29391158123626243,-0.29574034972478985,-0.29727453396452347,-0.29851358128156347,-0.2994544451742904,-0.30009482660988346,-0.30043907902783173,-0.30048644363405164,-0.3002369544043975,-0.29968819678814346,-0.2988444313574429,-0.2977048064508765,-0.2962719042333858,-0.29454317198576974,-0.2925200231035754,-0.2902045731500091,-0.2876022809123594,-0.2847133796914938,-0.28154140071122247,-0.27809048676073667,-0.27436270583704647,-0.2703665745543449,-0.26610524813698555,-0.26158238012185503,-0.25680474076422527,-0.2517742032662073,-0.2464935808285531,-0.24096598110942027,-0.23519855715870805,-0.22919065210989617,-0.22294815964121067,-0.216477551020404,-0.20978904844956445,-0.20289009717093992,-0.19578529751522875,-0.18849136560284127,-0.1810102720333381,-0.17335332623615154,-0.16552932116242403,-0.15754446533330008,-0.1494055335341655,-0.141119776212369,-0.13269158757842503,-0.12412621123921029,-0.11543344583116043,-0.10661783052843572,-0.09768974155699829,-0.08866263788534111,-0.07955032956578706,-0.07036309089673469,-0.06111613853088287,-0.051824258760106816,-0.04250384833178472,-0.03316965050170948,-0.02383739609051122,-0.014517898480146497,-0.00521285872839692,0.004084069854356758,0.013377716369566438,0.022678964415954628,0.03199791841264746,0.04134623887290685,0.05072829056150665,0.06014998301207159,0.06960936374549687,0.07908892160637689,0.08855068744478754,0.09794356384062872,0.10720878615596977,0.11629326145552335,0.12514991959047528,0.13374545516319478,0.14207020091055017,0.15012393938707272,0.15792746608076888,0.16551126865840357,0.1729042968130615,0.18013571994835326,0.1872239892183252,0.19418299168723718,0.20100573965434845,0.2076839316858779,0.2142059797503866,0.22054968628960595,0.22669845070103078,0.2326348093954518,0.2383522458039774,0.24384287073319427,0.2491022174907651,0.2541293098371375,0.2589202699947854,0.2634683865999179,0.2677700650071298,0.27181899023759926,0.2756002672767167,0.2791048721375289,0.28231577838682104,0.28522354073704403,0.2878230537497963,0.2901076694828819,0.2920783437903407,0.29374310403406084,0.295107993386028,0.2961895263765827,0.2970056784978085,0.2975819271104611,0.29794495005548816,0.298109264082986,0.2980740741579594,0.2978323971097816,0.2973591836734637,0.296622924641549,0.2955794967043364,0.29418154658089085,0.2923728011959445,0.2900962060295761,0.2873037962354698,0.28396753800504204,0.28032650994085717,0.2763886650341475,0.27216195627614015,0.26765433665806226,0.2628737591711411,0.2578281768066035,0.25252554255567694,0.2469738094095883,0.2411809303595648,0.2351548583968336,0.2289035465126218,0.22243494769815644,0.21575701494466482,0.208877701243374,0.201804959585511,0.19454674296230312,0.1871110043649775,0.179505696784761,0.1717387732128811,0.16381818664056474,0.1557518900590391,0.14754783645953137,0.1392139788332685,0.1307582701714778};
		T zGoals[200] = {0.31756840547539744,0.32748579299353975,0.3378005717933035,0.3484792783644661,0.3594884491968049,0.3707946207800972,0.38236432960412026,0.39416411215865155,0.40616050493346834,0.4183200444183479,0.4306092671030677,0.44299470947740494,0.455442908031137,0.4679203992540413,0.48039371963589506,0.49282940566647565,0.5051939938355604,0.5174540206329267,0.5295760225483518,0.541526536071613,0.5532720976924878,0.5647792439007534,0.5760145111861872,0.5869444360385665,0.5975355549476685,0.607754404403259,0.617684862624283,0.6269833110602612,0.6356398015809976,0.6436439919363848,0.6509877754875409,0.6576613603932012,0.6636610682008525,0.6689826360732843,0.67361769235995,0.6775587102765505,0.6807894425694675,0.6832982853518634,0.6850685995152646,0.6860878343790213,0.6863475050397387,0.6858378423067206,0.6845542073433015,0.6824970237151333,0.679674950734998,0.6760903644476528,0.6717601780334646,0.6666986364356934,0.6609289904640975,0.6544774785385726,0.6473731907857357,0.6396420054814256,0.6313175949625012,0.6224353167682047,0.6130293234274724,0.6031408593626014,0.592806201725962,0.5820708170060365,0.5709740379170426,0.5595578699404182,0.5478698928627949,0.5359537973679934,0.5238581689279385,0.5116302430406027,0.4993208702348768,0.48697884889804044,0.4746532265736393,0.4623956012593628,0.4502485492310045,0.4382596910462214,0.42647866542842733,0.41494764320821875,0.4037154159777041,0.39282851027202587,0.3823335341683771,0.37227688282859595,0.36269856168881953,0.3536372194160615,0.3451304536909037,0.33721132075471055,0.32990808625336293,0.32324779496703726,0.3172587080115004,0.31196097533352374,0.3073723368592661,0.3035111825862362,0.3003931753833552,0.29803437903462704,0.2964420439874006,0.29562574916758594,0.2955914743255737,0.29633569503272444,0.29786307504133164,0.3001661781693752,0.30323465990169074,0.3070520940451594,0.3115998595664622,0.31685456748736623,0.3227967201975068,0.32939373258736826,0.336620401368088,0.34444137126548074,0.35282689981652365,0.3617486647489115,0.37117885795827055,0.3810878162585716,0.39144908831456365,0.4022280096944361,0.41338530657545247,0.42488278556704895,0.43667841400710394,0.4487240639652002,0.46096913859882693,0.47336419850958344,0.48584480962195276,0.4983474665337738,0.5108078008561817,0.5231640943169621,0.5353543092708679,0.5473260617454424,0.5590277695983947,0.5704169154454125,0.5814512174681081,0.5920942512854084,0.6023199392964617,0.6120999705542476,0.6214094905886763,0.6302189177557694,0.6384948605857313,0.6462095585403849,0.6533240617001391,0.6598152959296799,0.6656559786178493,0.6708180864798622,0.6752789417653723,0.6790134023420558,0.6819951301275096,0.6841972139799184,0.6856012933475145,0.6861863032005122,0.6859428344922742,0.6848659833744687,0.6829691340687087,0.6802671521438632,0.6767869940428872,0.6725559197263683,0.6675988289655357,0.6619506036376687,0.6556389703050904,0.6486908922059266,0.6411394935332501,0.6330153548211616,0.6243554553896911,0.6151955559582207,0.6055661079526033,0.5954998822170263,0.5850395750753018,0.5742180207932119,0.563083467349193,0.5516783030193103,0.5400466850891197,0.5282336225055959,0.5162846587691582,0.5042482411832561,0.49216898910506657,0.4800977462683095,0.4680759949262634,0.45614115835012375,0.4443280391401759,0.4326669709393109,0.42118572108087715,0.40991017010577024,0.3988536909103188,0.3880358943577357,0.37746325851094437,0.3677153816185399,0.3583626678734707,0.34943548878219216,0.34096421585115233,0.33297922058679913,0.3255108744955808,0.3185895490839454,0.31224561585834093,0.30650944632521565,0.30141141199101745,0.2969818843621946,0.29325123494519506,0.29024983524646697,0.28800805677245844,0.2865562710296175,0.28592484952439223,0.2861441637632308,0.28724458525258123,0.2892564854988917,0.2922102360086102,0.2961362082881848,0.30106477384406377,0.30702630418269494,0.3140511708105266,0.32216974523400665};
		// and the cost params for the fig 8 tracking
		float Q_EE1_fig8 = 300; float Q_EE2_fig8 = 0; float QF_EE1_fig8 = 300.0; float QF_EE2_fig8 = 0;
		float R_EE_fig8 = 0.001; // make 0.001 for the move to inital goal and then to 0.0005 for motion
		float Q_xdEE_fig8 = 5; float QF_xdEE_fig8 = 5; float Q_xEE_fig8 = 5; float QF_xEE_fig8 = 5;

    	LCM_Fig8Goal_Handler(double tTime, double eLim, double vLim) : totalTime(tTime), eNormLim(eLim), vNormLim(vLim) {
    		zeroTime = 0; inFig8 = 0; costSent = 0;	totalError = 0;	numIters = 0; currRep = 0; if(!lcm_ptr.good()){printf("LCM Failed to Init in Goal Handler\n");}
    	}
    	~LCM_Fig8Goal_Handler(){}

    	// fig 8 goals
    	int getFig8Goal(T *goal, double time){return loadFig8Goal<T>(goal,time,totalTime,xGoals,yGoals,zGoals);}

    	// keep track of traj times
    	void newTrajCallback_f(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_trajectory_f *msg){
            if (inFig8){gettimeofday(&end,NULL); timeCount++; timeTotal += time_delta_ms(start,end);} gettimeofday(&start,NULL);
        }
        void newTrajCallback_d(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_trajectory_d *msg){
            if (inFig8){gettimeofday(&end,NULL); timeCount++; timeTotal += time_delta_ms(start,end);} gettimeofday(&start,NULL);
        }

		// update goal based on status
		void handleStatus(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_iiwa_status *msg){
			// get current goal
			T goal[3]; double time = inFig8 ? msg->utime - zeroTime : 0; int rep = getFig8Goal(goal,time);
			// compute the position error norm and velocity norm
			T eNorm; T vNorm; T currX[STATE_SIZE]; T eePos[NUM_POS];
			for(int i=0; i < STATE_SIZE; i++){
				if(i < NUM_POS){currX[i] = static_cast<T>(msg->joint_position_measured[i]);}
				else{			currX[i] = static_cast<T>(msg->joint_velocity_estimated[i-NUM_POS]);}
			}
			evNorm<T>(currX, goal, &eNorm, &vNorm, eePos);		totalError += static_cast<double>(eNorm);	numIters++;
			// debug print
			// printf("[%f] eNorm[%f] vNorm[%f] for goal[%f %f %f] and Pos[%f %f %f]\n",static_cast<double>(msg->utime),eNorm,vNorm,goal[0],goal[1],goal[2],eePos[0],eePos[1],eePos[2]);
			// print the error for each rep
			if(rep > currRep){
				printf("[!] Rep [%d] has total error [%f] with time [%f]\n",rep,totalError/numIters,timeTotal/timeCount); 
				totalError = 0; numIters = 0; currRep++; timeCount = 0; timeTotal = 0;
			}
			// then figure out if we are in the goal moving time
			if(inFig8){
				// then load in goal pos and zero out vel, orientation, angularVelocity (for now) -- note orientation is size 4 (quat)
				drake::lcmt_target_twist dataOut;               dataOut.utime = msg->utime;
				for (int i = 0; i < 3; i++){dataOut.position[i] = static_cast<float>(goal[i]);	dataOut.velocity[i] = 0;	
											dataOut.orientation[i] = 0;							dataOut.angular_velocity[i] = 0;}
				dataOut.orientation[3] = 0;
				// and publish it to goal channel
			    lcm_ptr.publish(ARM_GOAL_CHANNEL,&dataOut);
			}
			else {
				// reset the zeroTime and set that we are inFig8 next time
				if (eNorm < eNormLim && vNorm < vNormLim){zeroTime = msg->utime; inFig8 = 1; totalError = 0; numIters = 0;}
				// else if close but not there yet update the cost func to care more about moving to goals
				else if (!costSent && eNorm < 2.5*eNormLim && vNorm < 2.5*vNormLim){
					drake::lcmt_cost_params dataOut;		dataOut.utime = msg->utime;
					dataOut.q_ee1   = Q_EE1_fig8;		dataOut.q_ee2   = Q_EE2_fig8;
					dataOut.qf_ee1  = QF_EE1_fig8;		dataOut.qf_ee2  = QF_EE2_fig8;
					dataOut.q_xdee  = Q_xdEE_fig8;		dataOut.qf_xdee = QF_xdEE_fig8;
					dataOut.q_xee   = Q_xEE_fig8;		dataOut.qf_xee  = QF_xEE_fig8;
					dataOut.r_ee    = R_EE_fig8;		lcm_ptr.publish(COST_PARAMS_CHANNEL,&dataOut); costSent = 1;
				}
			}
		}
};
template <typename T>
void runFig8GoalLCM(LCM_Fig8Goal_Handler<T> *handler){
	lcm::LCM lcm_ptr; if(!lcm_ptr.good()){printf("LCM Failed to init in goal handler\n");}
	lcm::Subscription *sub = lcm_ptr.subscribe(ARM_STATUS, &LCM_Fig8Goal_Handler<T>::handleStatus, handler); lcm::Subscription *sub2;
	if (std::is_same<T, float>::value){sub2 = lcm_ptr.subscribe(ARM_TRAJ_CHANNEL, &LCM_Fig8Goal_Handler<T>::newTrajCallback_f, handler);}
    else if (std::is_same<T, double>::value){sub2 = lcm_ptr.subscribe(ARM_TRAJ_CHANNEL, &LCM_Fig8Goal_Handler<T>::newTrajCallback_d, handler);}
    else{printf("Timing only defined for floats and doubles\n");}
    sub->setQueueCapacity(1); sub2->setQueueCapacity(1);
    while(0 == lcm_ptr.handle());
    // while(1){lcm_ptr.handle();usleep(5000);}
}

// trajRunner takes messages of new trajectories to execute and current status's and returns torque commands
template <typename T, int KNOT_POINTS, int TRAJ_RUNNER_TIME_STEPS>
class LCM_TrajRunner {
    public:
        T *x, *u, *KT; // current trajectories
        int ld_x, ld_u, ld_KT; // dimms
        int64_t t0; // t0 for the current traj
        lcm::LCM lcm_ptr; // ptr to LCM object for publish ability
        bool ready;

        // init local vars to match size of passed in vars and get LCM
        LCM_TrajRunner(int _ld_x, int _ld_u, int _ld_KT) : ld_x(_ld_x), ld_u(_ld_u), ld_KT(_ld_KT){
            x = (T *)std::malloc(ld_x*KNOT_POINTS*sizeof(T));                 u = (T *)std::malloc(ld_x*KNOT_POINTS*sizeof(T));
            KT = (T *)std::malloc(ld_KT*DIM_KT_c*KNOT_POINTS*sizeof(T));      ready = 0;
            if(!lcm_ptr.good()){printf("LCM Failed to Init in Traj Runner\n");}
        } 
        // free and delete
        ~LCM_TrajRunner(){free(x); free(u); free(KT);}
        
        // lcm new traj callback function
        void newTrajCallback_f(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_trajectory_f *msg){
            t0 = msg->utime; ready = 1; std::memcpy(u, &(msg->u[0]), msg->u_size); std::memcpy(x, &(msg->x[0]), msg->x_size); std::memcpy(KT,&(msg->KT[0]),msg->KT_size);
        }
        void newTrajCallback_d(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_trajectory_d *msg){
            t0 = msg->utime; ready = 1; std::memcpy(u, &(msg->u[0]), msg->u_size); std::memcpy(x, &(msg->x[0]), msg->x_size); std::memcpy(KT,&(msg->KT[0]),msg->KT_size);
        }

        // lcm STATUS callback function
        void statusCallback(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_iiwa_status *msg){ 
            if(!ready){return;}
            // construct output msg container and begin to load it with data
            drake::lcmt_iiwa_command_hardware dataOut;
            #pragma unroll
            for(int i=0; i < 6; i++){dataOut.wrench[i] = 0.0;}
            dataOut.num_joints = static_cast<int32_t>(NUM_POS);         dataOut.joint_position.resize(dataOut.num_joints);
            dataOut.utime = static_cast<int64_t>(msg->utime);           dataOut.joint_torque.resize(dataOut.num_joints);  // NUM_POS = CONTROL_SIZE for arm so this works
            // get the correct controls for this time
            int err = getHardwareControls<T,KNOT_POINTS,TRAJ_RUNNER_TIME_STEPS,true,false>(
                                            &(dataOut.joint_position[0]), &(dataOut.joint_torque[0]), 
                                            x, u, KT, static_cast<double>(t0), static_cast<double>(msg->utime),
                                            &(msg->joint_position_measured[0]), &(msg->joint_velocity_estimated[0]),  
                                            ld_x, ld_u, ld_KT);;
            // then publish
            if (!err){lcm_ptr.publish(ARM_COMMAND_CHANNEL,&dataOut);}
            else{printf("[!]CRITICAL ERROR: Asked to execute beyond bounds of current traj.\n");}
        }
};

template <typename T, int KNOT_POINTS, int TRAJ_RUNNER_TIME_STEPS>
void runTrajRunner(int ld_x, int ld_u, int ld_KT){
    // init LCM and allocate a traj runner
    lcm::LCM lcm_ptr; if(!lcm_ptr.good()){printf("LCM Failed to Init in Traj Runner main loop\n");}
    LCM_TrajRunner<T,KNOT_POINTS,TRAJ_RUNNER_TIME_STEPS> tr = LCM_TrajRunner<T,KNOT_POINTS,TRAJ_RUNNER_TIME_STEPS>(ld_x, ld_u, ld_KT);
    // subscribe to everything
    lcm::Subscription *statusSub = lcm_ptr.subscribe(ARM_STATUS, &LCM_TrajRunner<T,KNOT_POINTS,TRAJ_RUNNER_TIME_STEPS>::statusCallback, &tr);
    lcm::Subscription *trajSub;
    if (std::is_same<T, float>::value){trajSub = lcm_ptr.subscribe(ARM_TRAJ_CHANNEL, &LCM_TrajRunner<T,KNOT_POINTS,TRAJ_RUNNER_TIME_STEPS>::newTrajCallback_f, &tr);}
    else if (std::is_same<T, double>::value){trajSub = lcm_ptr.subscribe(ARM_TRAJ_CHANNEL, &LCM_TrajRunner<T,KNOT_POINTS,TRAJ_RUNNER_TIME_STEPS>::newTrajCallback_d, &tr);}
    else{printf("Traj runner only defined for floats and doubles\n"); return;}
    // only execute latest message (no lag)
    statusSub->setQueueCapacity(1); trajSub->setQueueCapacity(1);
    // handle forever
    while(0 == lcm_ptr.handle());
    // while(1){lcm_ptr.handle();usleep(1000);}
}

template <typename T>
class LCM_IIWA_STATUS_printer {
    public:
        LCM_IIWA_STATUS_printer(){}
        ~LCM_IIWA_STATUS_printer(){}

        void handleMessage(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_iiwa_status *msg){                
            // printf("%ld | %f %f %f %f %f %f %f | %f %f %f %f %f %f %f | %f %f %f %f %f %f %f | %f %f %f %f %f %f %f \n",msg->utime,
            //     msg->joint_position_measured[0],msg->joint_position_measured[1],msg->joint_position_measured[2],msg->joint_position_measured[3],
            //     msg->joint_position_measured[4],msg->joint_position_measured[5],msg->joint_position_measured[6],
            //     msg->joint_velocity_estimated[0],msg->joint_velocity_estimated[1],msg->joint_velocity_estimated[2],msg->joint_velocity_estimated[3],
            //     msg->joint_velocity_estimated[4],msg->joint_velocity_estimated[5],msg->joint_velocity_estimated[6],
            //     msg->joint_torque_commanded[0],msg->joint_torque_commanded[1],msg->joint_torque_commanded[2],msg->joint_torque_commanded[3],
            //     msg->joint_torque_commanded[4],msg->joint_torque_commanded[5],msg->joint_torque_commanded[6],
            //     msg->joint_torque_measured[0],msg->joint_torque_measured[1],msg->joint_torque_measured[2],msg->joint_torque_measured[3],
            //     msg->joint_torque_measured[4],msg->joint_torque_measured[5],msg->joint_torque_measured[6]);
            double s_eePos[6]; double s_tempMem[34*NUM_POS]; computedEEPos4x4_scratch<double>(s_eePos,(double *)&(msg->joint_position_measured[0]),s_tempMem);
            printf("[%ld] eePos: [%f %f %f] w/ jointVel [%f %f %f %f %f %f %f]\n",msg->utime,s_eePos[0],s_eePos[1],s_eePos[2],
                msg->joint_velocity_estimated[0],msg->joint_velocity_estimated[1],msg->joint_velocity_estimated[2],
                msg->joint_velocity_estimated[3],msg->joint_velocity_estimated[4],msg->joint_velocity_estimated[5],
                msg->joint_velocity_estimated[6]);
        }
};

template <typename T>
void run_IIWA_STATUS_printer(lcm::LCM *lcm_ptr, LCM_IIWA_STATUS_printer<T> *handler){
    lcm::Subscription *sub = lcm_ptr->subscribe(ARM_STATUS_CHANNEL, &LCM_IIWA_STATUS_printer<T>::handleMessage, handler);
    while(0 == lcm_ptr->handle());
}

template <typename T>
class LCM_IIWA_COMMAND_printer {
    public:
        LCM_IIWA_COMMAND_printer(){}
        ~LCM_IIWA_COMMAND_printer(){}

        void handleMessage(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_iiwa_command_hardware *msg){                
            printf("%ld | %f %f %f %f %f %f %f | %f %f %f %f %f %f %f \n",msg->utime,
                        msg->joint_position[0],msg->joint_position[1],msg->joint_position[2],
                        msg->joint_position[3],msg->joint_position[4],msg->joint_position[5],msg->joint_position[6],
                        msg->joint_torque[0],msg->joint_torque[1],msg->joint_torque[2],
                        msg->joint_torque[3],msg->joint_torque[4],msg->joint_torque[5],msg->joint_torque[6]);
            // double s_eePos[6]; double s_tempMem[34*NUM_POS]; computedEEPos4x4_scratch<double>(s_eePos,(double *)&(msg->joint_position_measured[0]),s_tempMem);
            // printf("[%ld] eePosDes: [%f %f %f] control: [%f %f %f %f %f %f %f ]\n",msg->utime,s_eePos[0],s_eePos[1],s_eePos[2],
            //                             msg->joint_torque[0],msg->joint_torque[1],msg->joint_torque[2],msg->joint_torque[3],
            //                             msg->joint_torque[4],msg->joint_torque[5],msg->joint_torque[6]);
        }
};

template <typename T>
void run_IIWA_COMMAND_printer(lcm::LCM *lcm_ptr, LCM_IIWA_COMMAND_printer<T> *handler, int hardware = 0){
    lcm::Subscription *sub = lcm_ptr->subscribe(ARM_COMMAND_CHANNEL, &LCM_IIWA_COMMAND_printer<T>::handleMessage, handler);
    while(0 == lcm_ptr->handle());
}

template <typename T>
class LCM_traj_printer {
    public:
        LCM_traj_printer(){}
        ~LCM_traj_printer(){}

        void handleMessage_d(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_trajectory_d *msg){                
            double s_eePos[6]; double s_tempMem[34*NUM_POS]; computedEEPos4x4_scratch<double>(s_eePos,(double *)&(msg->x[0]),s_tempMem);
            printf("[%ld] new traj computed with eePos0: [%f %f %f]\n",msg->utime,s_eePos[0],s_eePos[1],s_eePos[2]);
        }
        void handleMessage_f(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_trajectory_f *msg){                
            float s_eePos[6]; float s_tempMem[34*NUM_POS]; computedEEPos4x4_scratch<float>(s_eePos,(float *)&(msg->x[0]),s_tempMem);
            printf("[%ld] new traj computed with eePos0: [%f %f %f]\n",msg->utime,s_eePos[0],s_eePos[1],s_eePos[2]);
        }
};

template <typename T>
void run_traj_printer(lcm::LCM *lcm_ptr, LCM_traj_printer<T> *handler){
    if (std::is_same<T, float>::value){lcm::Subscription *sub = lcm_ptr->subscribe(ARM_TRAJ_CHANNEL, &LCM_traj_printer<T>::handleMessage_f, handler);}
    else{lcm::Subscription *sub = lcm_ptr->subscribe(ARM_TRAJ_CHANNEL, &LCM_traj_printer<T>::handleMessage_d, handler);}
    while(0 == lcm_ptr->handle());
}

template <typename T>
int runPrinters(){
    lcm::LCM lcm_ptr;   if(!lcm_ptr.good()){printf("LCM Failed to Init in Printers\n");} 
    printf("Which printer would you like to run (q to exit)?\n[1] Status\n[2] Command\n[3] Trajectory\n");
    int printerType = getInt<'q'>(3, 1); if(printerType == -1){return 0;}
    if(printerType == 1){
        LCM_IIWA_STATUS_printer<T> *shandler = new LCM_IIWA_STATUS_printer<T>;
        run_IIWA_STATUS_printer<T>(&lcm_ptr,shandler);
        delete shandler;    
    }
    else if(printerType == 2){
        LCM_IIWA_COMMAND_printer<T> *chandler = new LCM_IIWA_COMMAND_printer<T>;
        run_IIWA_COMMAND_printer<T>(&lcm_ptr,chandler);
        delete chandler;
    }
    else if(printerType == 3){
        LCM_traj_printer<T> *thandler = new LCM_traj_printer<T>;
        run_traj_printer<T>(&lcm_ptr,thandler);
        delete thandler;
    }
    return 0;
}

class LCM_Simulator_Handler {
    public:
        int numSteps;               struct timeval start, end;   int64_t currTime;                  double prevX[STATE_SIZE];
        double nextX[STATE_SIZE];   double currX[STATE_SIZE];    double qdd[NUM_POS];               double Minv[NUM_POS*NUM_POS];
        double Tbody[36*NUM_POS];   double I[36*NUM_POS];        double torqueCom[CONTROL_SIZE];    double currU[NUM_POS];
        lcm::LCM lcm_ptr;           int hertz, debug;            double dt;

        LCM_Simulator_Handler(double *xInit, int _numSteps = 50, int _hertz = 1000, int _debug = 0) : numSteps(_numSteps), hertz(_hertz), debug(_debug) {
            for(int i=0; i < STATE_SIZE; i++){currX[i] = xInit[i];}
            for(int i=0; i < CONTROL_SIZE; i++){torqueCom[i] = 0;}
            if(!lcm_ptr.good()){printf("LCM Failed to Init in Simulator\n");}
            initI<double>(I);       initT<double>(Tbody);     gettimeofday(&start,NULL);    currTime = 0;       dt = 1.0/hertz;
        }
        ~LCM_Simulator_Handler(){}

        // lcm callback function to update the torqueCom
        void handleMessage(const lcm::ReceiveBuffer *rbuf, const std::string &chan, const drake::lcmt_iiwa_command_hardware *msg){
            #pragma unroll
            for(int i = 0; i < CONTROL_SIZE; i++){torqueCom[i] = msg->joint_torque[i];}
        }

        // do simulation
        void simulate(double simTime){
            // load into local vars so nothing changes during simulation step
            #pragma unroll
            for(int i = 0; i < STATE_SIZE; i++){prevX[i] = currX[i];}
            #pragma unroll
            for(int i = 0; i < CONTROL_SIZE; i++){currU[i] = torqueCom[i];}
            // update timing and get step size
            currTime += static_cast<int64_t>(1000000*simTime);
            double stepTime = simTime/static_cast<double>(numSteps);
            // take steps by getting qdd and applying Euler rule
            for (int i=0; i< numSteps; i++){
                forwardDynamics(qdd,currU,&currX[NUM_POS],currX,I,Tbody,Minv);
                for (int ind = 0; ind < NUM_POS; ind++){
                    nextX[ind]          = currX[ind]            + stepTime*currX[ind+NUM_POS];
                    nextX[ind+NUM_POS]  = currX[ind+NUM_POS]    + stepTime*qdd[ind];
                }
                #pragma unroll
                for(int i = 0; i < STATE_SIZE; i++){currX[i] = nextX[i];}
            }
            if (debug == 1){
                printf("%f:%f %f %f %f %f %f %f:%f %f %f %f %f %f %f %f %f %f %f %f %f %f:%f %f %f %f %f %f %f %f %f %f %f %f %f %f\n",
                   simTime,
                   currU[0],currU[1],currU[2],currU[3],currU[4],currU[5],currU[6],
                   prevX[0],prevX[1],prevX[2],prevX[3],prevX[4],prevX[5],prevX[6],prevX[7],prevX[8],prevX[9],prevX[10],prevX[11],prevX[12],prevX[13],
                   currX[0],currX[1],currX[2],currX[3],currX[4],currX[5],currX[6],currX[7],currX[8],currX[9],currX[10],currX[11],currX[12],currX[13]);    
            }
            else if (debug == 2){
                double s_eePos[6]; double s_tempMem[34*NUM_POS]; computedEEPos4x4_scratch<double>(s_eePos,currX,s_tempMem);
                printf("%f %f %f\n",s_eePos[0],s_eePos[1],s_eePos[2]); 
            }
            else if (debug == 3){
                printf("%f %f %f %f %f %f %f | %f %f %f %f %f %f %f\n",currX[0],currX[1],currX[2],currX[3],currX[4],currX[5],currX[6],currX[7],currX[8],currX[9],currX[10],currX[11],currX[12],currX[13]);
            }
        }

        // publish currX
        void publish(){
            //construct output msg container and begin to load it with data
            drake::lcmt_iiwa_status dataOut;                                dataOut.utime = currTime;
            dataOut.num_joints = static_cast<int32_t>(NUM_POS);             dataOut.joint_position_measured.resize(dataOut.num_joints);      
            dataOut.joint_velocity_estimated.resize(dataOut.num_joints);    dataOut.joint_position_commanded.resize(dataOut.num_joints);  
            dataOut.joint_position_ipo.resize(dataOut.num_joints);          dataOut.joint_torque_measured.resize(dataOut.num_joints);  
            dataOut.joint_torque_commanded.resize(dataOut.num_joints);      dataOut.joint_torque_external.resize(dataOut.num_joints);
            for(int i = 0; i < NUM_POS; i++){
                dataOut.joint_position_commanded[i] = 0;        dataOut.joint_position_ipo[i] = 0;
                double val = torqueCom[i];                      dataOut.joint_torque_external[i] = 0;
                dataOut.joint_torque_measured[i] = val;         dataOut.joint_torque_commanded[i] = val;
                dataOut.joint_position_measured[i] = currX[i];  dataOut.joint_velocity_estimated[i] = currX[i+NUM_POS];
            }
            lcm_ptr.publish(ARM_STATUS_CHANNEL,&dataOut);
        }

        // run the simulator for dt
        void runSim(){
            simulate(dt);
            double simTime;
            while(1){
                gettimeofday(&end,NULL);
                simTime = time_delta_s(start,end);
                if (simTime >= dt){
                    gettimeofday(&start,NULL);
                    publish();
                    break;
                }
            } 
        }
};

template <typename T>
void runLCMSimulator(void){
    // Get user input on simulator parameters
    printf("What should the simulator rate be (in hz)?\n");
    int hertz = getInt<'q'>(10000,100);
    printf("How many substeps should the simulator take on each tick?\n");
    int numSteps = getInt<'q'>(1000,1);
    // then ask for debug mode
    printf("What debug mode would you like? (0: None, 1:dt,uk,xk,xkp1 2:eePos, 3:qk|qdk)\n");
    int debug = getInt<'q'>(3,0);
    // Get initial point
    double xInit[STATE_SIZE]; loadPoint<double,NUM_POS,1>(xInit);
    // then launch simulator on enter
    printf("Press enter to launch the simulator\n");
    keyboardHold();
    // get LCM pointer -- subscribe and publish and go!
    lcm::LCM lcm_ptr;
    if(!lcm_ptr.good()){printf("LCM Failed to Init in Simulator\n");}
    double xInitd[STATE_SIZE];  for (int i = 0; i < STATE_SIZE; i++){xInitd[i] = static_cast<double>(xInit[i]);}
    LCM_Simulator_Handler handler = LCM_Simulator_Handler(xInitd, numSteps, hertz, debug);
    lcm::Subscription *sub = lcm_ptr.subscribe(ARM_COMMAND_CHANNEL, &LCM_Simulator_Handler::handleMessage, &handler);
    sub->setQueueCapacity(1);
    // poll the fd for updates
    while(1){   
        int lcm_fd = lcm_ptr.getFileno();  fd_set fds;     FD_ZERO(&fds);  FD_SET(lcm_fd, &fds);
        struct timeval timeout = {0,10};   // seconds, microseconds to wait for message
        if (select(lcm_fd + 1, &fds, 0, 0, &timeout)) {if (FD_ISSET(lcm_fd, &fds)){lcm_ptr.handle();}} 
        handler.runSim();
    }
}

template <typename T>
int runLCMHelpers(void){
	printf("\nWhich LCM Helper would you like to run (q to exit)?\n[1] Simulator\n[2] Printer\n[3] TrajRunner\n[4] GoalHandler\n[5] TrajRunner+GoalHandler\n");
    int flag = getInt<'q'>(5, 1); if(flag == -1){return 0;}
    // run the simulator
    if (flag == 1){runLCMSimulator<T>();}
    // run various printers
    else if (flag == 2){runPrinters<T>();}
    // run the traj runner
    else if (flag == 3){
    	printf("How many knot points do you want to use (q to exit)?\n[1] 64\n[2] 128\n[3] 256\n[4] 512\n");
		int knots_flag = getInt<'q'>(4, 1); if(knots_flag == -1){return 0;}
		if(knots_flag == 1){runTrajRunner<T,64,16>(DIM_x_r,DIM_u_r,DIM_KT_r);}
		else if(knots_flag == 2){runTrajRunner<T,128,32>(DIM_x_r,DIM_u_r,DIM_KT_r);}
		else if(knots_flag == 3){runTrajRunner<T,256,32>(DIM_x_r,DIM_u_r,DIM_KT_r);}
		else{runTrajRunner<T,512,32>(DIM_x_r,DIM_u_r,DIM_KT_r);}
    }
    // run the goal monitor
    else if (flag == 4){
    	printf("How many seconds long should one figure eight of the tracked trajectory be [1-100] seconds? (q to exit)\n");
		int timeInt = getInt<'q'>(100, 1); if(timeInt == -1){return 0;} double totalTime_us = 1000000.0*static_cast<double>(timeInt);
		printf("What is the ||xyzError|| before Fig8? [1] 0.01 [2] 0.025 [3] 0.05 [4] 0.1 (q to exit)\n");
		int eFlag = getInt<'q'>(4, 1); if(eFlag == -1){return 0;} double eLim = eFlag == 1 ? 0.01 : (eFlag == 2 ? 0.025 : (eFlag == 3 ? 0.05 : 0.1));
		printf("What is the ||vel|| before Fig8? [1] 0.01 [2] 0.025 [3] 0.05 [4] 0.1 (q to exit)\n");
		int vFlag = getInt<'q'>(4, 1); if(vFlag == -1){return 0;} double vLim = vFlag == 1 ? 0.01 : (vFlag == 2 ? 0.025 : (vFlag == 3 ? 0.05 : 0.1));
		// then allocate handle and load initial goal and nominal point
    	LCM_Fig8Goal_Handler<T> *handler = new LCM_Fig8Goal_Handler<T>(totalTime_us, eLim, vLim);
 		runFig8GoalLCM<T>(handler);
 		delete handler;
    }
    else if (flag == 5){
    	printf("How many seconds long should one figure eight of the tracked trajectory be [1-100] seconds? (q to exit)\n");
		int timeInt = getInt<'q'>(100, 1); if(timeInt == -1){return 0;} double totalTime_us = 1000000.0*static_cast<double>(timeInt);
		// printf("What is the ||xyzError|| before Fig8? [1] 0.01 [2] 0.025 [3] 0.05 [4] 0.1 (q to exit)\n");
		// int eFlag = getInt<'q'>(4, 1); if(eFlag == -1){return 0;} double eLim = eFlag == 1 ? 0.01 : (eFlag == 2 ? 0.025 : (eFlag == 3 ? 0.05 : 0.1));
		// printf("What is the ||vel|| before Fig8? [1] 0.01 [2] 0.025 [3] 0.05 [4] 0.1 (q to exit)\n");
		// int vFlag = getInt<'q'>(4, 1); if(vFlag == -1){return 0;} double vLim = vFlag == 1 ? 0.01 : (vFlag == 2 ? 0.025 : (vFlag == 3 ? 0.05 : 0.1));
		double eLim = 0.05; double vLim = 0.05;
		// printf("How many knot points do you want to use [1] 64 [2] 128 [3] 256 [4] 512 (q to exit)?\n");
		// int knots_flag = getInt<'q'>(4, 1); if(knots_flag == -1){return 0;}
		// then allocate handle and load initial goal and nominal point
    	LCM_Fig8Goal_Handler<T> *handler = new LCM_Fig8Goal_Handler<T>(totalTime_us, eLim, vLim);
    	// then launch the goal monitor in a thread and the traj runner in the main thread on enther
    	printf("Press enter to launch the Goal Monitor and Traj Runner\n");
    	keyboardHold();
 		std::thread fig8Thread = std::thread(&runFig8GoalLCM<T>, handler);
 		runTrajRunner<T,64,16>(DIM_x_r,DIM_u_r,DIM_KT_r);
		// if(knots_flag == 1){runTrajRunner<T,64,16>(DIM_x_r,DIM_u_r,DIM_KT_r);}
		// else if(knots_flag == 2){runTrajRunner<T,128,32>(DIM_x_r,DIM_u_r,DIM_KT_r);}
		// else if(knots_flag == 3){runTrajRunner<T,256,32>(DIM_x_r,DIM_u_r,DIM_KT_r);}
		// else{runTrajRunner<T,512,32>(DIM_x_r,DIM_u_r,DIM_KT_r);}
		fig8Thread.join(); delete handler;
    }
    return 0;
}